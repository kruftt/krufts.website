(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[675],{843:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),!function(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}(t,{bindSnapshot:function(){return s},createAsyncLocalStorage:function(){return o},createSnapshot:function(){return r}});let n=Object.defineProperty(Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available"),"__NEXT_ERROR_CODE",{value:"E504",enumerable:!1,configurable:!0});class a{disable(){throw n}getStore(){}run(){throw n}exit(){throw n}enterWith(){throw n}static bind(e){return e}}let i="undefined"!=typeof globalThis&&globalThis.AsyncLocalStorage;function o(){return i?new i:new a}function s(e){return i?i.bind(e):a.bind(e)}function r(){return i?i.snapshot():function(e,...t){return e(...t)}}},1620:(e,t,n)=>{"use strict";function a(e){let{moduleIds:t}=e;return null}Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"PreloadChunks",{enumerable:!0,get:function(){return a}}),n(1834),n(4175),n(3475),n(3082)},2909:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return l}});let a=n(1834),i=n(8210),o=n(6409);function s(e){return{default:e&&"default"in e?e.default:e}}n(1620);let r={loader:()=>Promise.resolve(s(()=>null)),loading:null,ssr:!0},l=function(e){let t={...r,...e},n=(0,i.lazy)(()=>t.loader().then(s)),l=t.loading;function h(e){let s=l?(0,a.jsx)(l,{isLoading:!0,pastDelay:!0,error:null}):null,r=!t.ssr||!!t.loading,h=r?i.Suspense:i.Fragment,c=t.ssr?(0,a.jsxs)(a.Fragment,{children:[null,(0,a.jsx)(n,{...e})]}):(0,a.jsx)(o.BailoutToCSR,{reason:"next/dynamic",children:(0,a.jsx)(n,{...e})});return(0,a.jsx)(h,{...r?{fallback:s}:{},children:c})}return h.displayName="LoadableComponent",h}},3475:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"workAsyncStorage",{enumerable:!0,get:function(){return a.workAsyncStorageInstance}});let a=n(6269)},5290:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return i}});let a=n(5679)._(n(2909));function i(e,t){var n;let i={};"function"==typeof e&&(i.loader=e);let o={...i,...t};return(0,a.default)({...o,modules:null==(n=o.loadableGenerated)?void 0:n.modules})}("function"==typeof t.default||"object"==typeof t.default&&null!==t.default)&&void 0===t.default.__esModule&&(Object.defineProperty(t.default,"__esModule",{value:!0}),Object.assign(t.default,t),e.exports=t.default)},5402:(e,t,n)=>{"use strict";n.d(t,{i:()=>i});var a=n(1834);function i(e){let t,n,{children:i}=e;return"string"==typeof i?(t=i,n=!1):[t,n]=i,(0,a.jsxs)("div",{className:"mt-10 mb-6",children:[(0,a.jsx)("h2",{className:"text-center m-auto text-3xl",children:t}),(0,a.jsx)("h3",{className:"text-center m-auto text-l mt-1",children:(0,a.jsx)("i",{children:n})})]})}},6145:(e,t,n)=>{"use strict";n.d(t,{default:()=>i.a});var a=n(5290),i=n.n(a)},6269:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"workAsyncStorageInstance",{enumerable:!0,get:function(){return a}});let a=(0,n(843).createAsyncLocalStorage)()},6409:(e,t,n)=>{"use strict";function a(e){let{reason:t,children:n}=e;return n}Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"BailoutToCSR",{enumerable:!0,get:function(){return a}}),n(1181)},8110:()=>{},8914:(e,t,n)=>{Promise.resolve().then(n.bind(n,8948))},8948:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>c});var a=n(1834);n(8110);var i=n(2074),o=n(2556),s=n(5402),r=n(1969),l=n(760),h=n(193);function c(){return(0,a.jsxs)("article",{children:[(0,a.jsxs)(s.i,{children:["Dimension 3","It All Revolves Around This"]}),(0,a.jsx)("p",{children:"Home at last, three dimensions. We can get from two to three dimensions in the same way as before, tack on another dimension, gesture at the pythagorean theorem, and call it good. This gives us a position in three 3 dimensions that we can add, subtract, and scale as desired."}),(0,a.jsx)(i.A,{children:"p=(a,b,c)"}),(0,a.jsx)("p",{children:"We would like to extend our ability to rotate into three dimensions and write down a corresponding algebra. We have previously noted that each component of behavior needs its own element. Lets look at what the pieces of a 3d rotation are."}),(0,a.jsxs)("p",{children:["The basics are similar to 2 dimensions in that rotation clearly involves an exchange from one direction to another in a cycle. The main difference is that in 3 dimensions there is an ",(0,a.jsx)("i",{children:"axis"})," of rotation that goes along for the ride, without any exchanging. We can picture a top spinning on its axis:"]}),(0,a.jsx)("div",{className:"flex flex-col items-center",children:(0,a.jsx)(h.default,{src:"quats/top.png",className:"max-w-7/8 max-h-70",alt:"A spinning top."})}),(0,a.jsx)("p",{children:"Therefore, in addition to knowing how much we want to rotate, we also need to know the axis of rotation."}),(0,a.jsxs)("p",{children:["First, we'll need to know how to ",(0,a.jsx)("i",{children:"stay"})," vs how to ",(0,a.jsx)("i",{children:"rotate"}),". Then we can use the pythagorean theorem to transition between the ",(0,a.jsx)("i",{children:"stay"})," and ",(0,a.jsx)("i",{children:"rotate"}),' behaviors, just like with 2 dimensions. In the 2D case, the rotation behavior was relatively straightforward, involving a swap and a flip to get the four directions going in a cycle. In the 3D case, there is an additional "rotating in place" behavior along the axis, alongside the cycling components. That is to say, when doing a quarter rotation along the first axis we expect our translated point to be:']}),(0,a.jsx)("div",{className:"text-center",children:(0,a.jsx)(o.A,{children:"(a,b,c) \\rightarrow (a,-c,b)"})}),(0,a.jsxs)("p",{children:["Where the first component ",(0,a.jsx)(o.A,{children:"a"})," is on the axis of rotation, and ",(0,a.jsx)(o.A,{children:"b"})," and ",(0,a.jsx)(o.A,{children:"c"})," are in the plane of rotation."]}),(0,a.jsx)(h.default,{src:"quats/3d_components.png",className:"max-w-7/8 max-h-100 m-auto",alt:"The components of a 3d rotation action."}),(0,a.jsxs)(s.i,{children:["A Bubble Bursts","The Singularity is Here"]}),(0,a.jsx)("p",{children:"Suppose we keep the exact same setup as in two dimensions and add an additional complex variable. Each can rotate in its plane, but stays still while the other is rotating:"}),(0,a.jsx)(h.default,{src:"quats/two_var.png",className:"max-w-7/8 max-h-80 m-auto",alt:"Two variable algebra."}),(0,a.jsxs)("div",{className:"flex justify-evenly",children:[(0,a.jsxs)(i.A,{children:["i^2=-1","ij=j"]}),(0,a.jsxs)(i.A,{children:["j^2=-1","ji=i"]})]}),(0,a.jsxs)("p",{children:["This does indeed allow us to rotate in these two planes, but there are some strange things afoot. The first is that ",(0,a.jsx)(o.A,{children:"ij \\neq ji"}),'. The order of actions can no longer be switched, they no longer commute ("commute" means "change together"). This is reflecting the fact that we have to be clear which axis is doing the rotating and which is being rotated. Doing rotations in reverse order does not usually result in the same translation. This is contrary to two dimensions in which we could exchange the order freely, and only the total amount of rotation mattered. Given this issue of axes rotating each other, losing commutativity appears to be an unavoidable complication.']}),(0,a.jsxs)("p",{children:["Moving on to the second issue and, unfortunately, it is catastrophic. We can see it by substituting ",(0,a.jsx)(o.A,{children:"j=ij"})," into itself:"]}),(0,a.jsxs)(i.A,{children:["j=ij","j=iij","j=-j","2j=0","i=j=0"]}),(0,a.jsx)(h.default,{src:"quats/bubble.png",className:"max-w-7/8 max-h-60 m-auto mt-8 mb-6",alt:"The bubble bursts."}),(0,a.jsxs)("p",{children:["Its all collapsed! What happened!? The issue is we are trying to get these elements to perform double duty. The first statements, like ",(0,a.jsx)(o.A,{children:"i^2=-1"}),", tell them to act as rotations, while the second statements, ",(0,a.jsx)(o.A,{children:"ij=j"}),", tell them to act as the identity. But when we combine these behaviors into a single statement, the algebra collapses back into the singularity, the only place where both of these behaviors can be part of the same action! Similarly, if ",(0,a.jsx)(o.A,{children:"i"})," and ",(0,a.jsx)(o.A,{children:"j"})," dont affect each other, how could we rotate between them? We cannot expect ",(0,a.jsx)(o.A,{children:"1"})," to step in and cause a rotation or else we will overload it's behavior as well, ending in another catastrophe."]}),(0,a.jsxs)(s.i,{children:["The Third Wheel","Two is Company, Three's a Crowd"]}),(0,a.jsx)("p",{children:"In 2 dimensions we only had one possible plane of rotation and were able to use a single algebraic variable to represent turning in that plane. Conveniently, this allowed us to think of points both as positions and actions, freely switching between perspectives. But now that we have three possible planes of rotation, not only do we need a variable for each one, but we still need extra room for information about how much to rotate at all. Therefore, looking ahead, we expect terms in our algebra to have the general form:"}),(0,a.jsx)(i.A,{children:"a + bi + cj + dk"}),(0,a.jsx)(h.default,{src:"quats/planar_actions.png",className:"max-w-7/8 max-h-100 m-auto mt-8 mb-4",alt:"Three planar actions."}),(0,a.jsxs)("p",{children:["Each complex variable represents a quarter rotation in one of the planes / around one of the axes, while the real component represents staying in place (or purely reversing). Furthermore, we know that the real component cannot be on an axis or else the algebra collapses. So now we have three algebraic variables, taking up all three dimensions. Where has the real component gone? Can we just forget it entirely? How do we interpret what these rotations do e.g. to ",(0,a.jsx)(o.A,{children:"1"}),"? We know that:"]}),(0,a.jsx)(i.A,{children:"i\\cdot1=i"}),(0,a.jsxs)("p",{children:["But ",(0,a.jsx)(o.A,{children:"1"})," is no longer in our picture!"]}),(0,a.jsxs)("p",{children:["Consider that turning all the way around on an axis is, at least positionally, equivalent to staying in place. Algebraically we can say ",(0,a.jsx)(o.A,{children:"i^4=1"}),". But we also know that ",(0,a.jsx)(o.A,{children:"i\\neq \\pm1"}),". This means ",(0,a.jsx)(o.A,{children:"i"})," must cycle with ",(0,a.jsx)(o.A,{children:"1"})," in exactly the same 4-step procedure as in the 2D case."]}),(0,a.jsxs)("div",{className:"".concat("bg-[url(https://cdn.jsdelivr.net/gh/kruftt/krufts.website@images/quats/twister.png)]"," bg-cover bg-center w-1/1 pb-10 z-10"),children:[(0,a.jsxs)(s.i,{children:["The Eye of the Storm","It's a Real Twister"]}),(0,a.jsxs)("div",{className:"flex flex-col items-center",children:[(0,a.jsx)("span",{children:"Therefore we have:"}),(0,a.jsxs)(i.A,{children:["i^2=-1","j^2=-1","k^2=-1"]}),(0,a.jsxs)(i.A,{children:["ij=k","jk=i","ki=j"]}),(0,a.jsxs)(i.A,{children:["ij=k","ijk=k^2","ijk=-1","ijk=i^2=j^2=k^2=-1"]})]})]}),(0,a.jsxs)("p",{children:["The algebra doesn't collapse, but things are getting a bit carried away! We have an algebra that can rotate around all three axes, but it does something else. Part of the component parallel to the axis of rotation, the part that is twisting in place, is getting cycled toward ",(0,a.jsx)(o.A,{children:"-1"}),". We were only considering the real component to be part of the action, meaning roughly ",(0,a.jsx)("i",{children:"stay-in-place"}),", but now its part of the resulting position! Meanwhile, the component along the axis is liable to collapse to ",(0,a.jsx)(o.A,{children:"0"}),' or to end up going the opposite way entirely! We only know where its "supposed" to go because of the context of the action that generated it.']}),(0,a.jsx)(h.default,{src:"quats/axis_actions.png",className:"max-w-7/8 max-h-80 m-auto",alt:"Two cycles of action."}),(0,a.jsxs)("p",{children:["Let's look at what the algebra is telling us. Its saying that the ",(0,a.jsx)("i",{children:"stay-in-place"})," and ",(0,a.jsx)("i",{children:"rotate-in-place"}),' behaviors are two aspects of the same overarching behavior, that of not moving. They both have the same effect on the final position, but how they get there is different. Therefore the "position" that multiplication gives back to us has its axis split in two, the part that stayed and the part that twisted.']}),(0,a.jsxs)("p",{children:["After doing a multiplication, we ",(0,a.jsx)("i",{children:"could"})," step out of the algebra and use the pythagorean theorem to sum up the lengths of the axis and twisted components, but this completely defeats the purpose of having an algebra! We need to be able to undo the twist without undoing the rotation. Another two-step process is in order."]}),(0,a.jsxs)(s.i,{children:["Controlled Opposition","How to Pull the Strings"]}),(0,a.jsx)(h.default,{src:"quats/cats_cradle.png",className:"max-w-7/8 max-h-80 m-auto",alt:"Can you see the pattern?"}),(0,a.jsx)("p",{children:"Is there anything fundamentally different between the two cycles that will allow them to be separated? Recall that the order in which axes multiply matters because it keeps track of which axis is rotating the other. We need to contrast this antisymmetric behavior on the plane of rotation, where order matters, with the symmetric behavior of an axis twisting on itself, where the order is irrelevant."}),(0,a.jsxs)("p",{children:["Let's first consider multiplying the point ",(0,a.jsx)(o.A,{children:"(i + j)"}),' "on the left" by ',(0,a.jsx)(o.A,{children:"i"}),", represented by the green arrow. The ",(0,a.jsx)(o.A,{children:"i"})," component, represented by the yellow dot, is along the axis of rotation while the ",(0,a.jsx)(o.A,{children:"j"})," component, represented by the orange dot, is in the plane of rotation:"]}),(0,a.jsx)(h.default,{src:"quats/ij_vs_ji.png",className:"max-w-7/8 max-h-100 m-auto",alt:"ij vs ji."}),(0,a.jsx)("div",{className:"text-center",children:(0,a.jsxs)(i.A,{children:["i(i + j)","i^2 + ij","-1 + k"]})}),(0,a.jsxs)("p",{children:["This takes ",(0,a.jsx)(o.A,{children:"i \\rightarrow -1"})," and ",(0,a.jsx)(o.A,{children:"j \\rightarrow k"}),". We can consider ",(0,a.jsx)(o.A,{children:"-1"})," as signifying that the parallel component, ",(0,a.jsx)(o.A,{children:"i"}),", has done a counter-clockwise twist. Now we'll undo this twist by multiplying by the conjugate, ",(0,a.jsx)(o.A,{children:"i^*"}),", but take advantage of the anti-commutativity in the plane of rotation by multiplying on the right, as represented by the gold arrow:"]}),(0,a.jsx)(h.default,{src:"quats/i_inverse.png",className:"max-w-7/8 max-h-100 m-auto",alt:"i*j vs ji*."}),(0,a.jsx)("div",{className:"text-center",children:(0,a.jsxs)(i.A,{children:["(-1 + k)i^*","-i^* + ki","i - j"]})}),(0,a.jsxs)("p",{children:["First note that the twisted, parallel component at ",(0,a.jsx)(o.A,{children:"-1"})," has been untwisted back to ",(0,a.jsx)(o.A,{children:"i"}),", as expected from multiplying by the conjugate. But what happened within the plane of rotation? What does it mean to multiply ",(0,a.jsx)("i",{children:"on the right"})," by ",(0,a.jsx)(o.A,{children:"i^*"}),"? The algebra tells us that this is the same as if ",(0,a.jsx)(o.A,{children:"k"})," was multiplying ",(0,a.jsx)(o.A,{children:"i^*"})," on the left, i.e. as if ",(0,a.jsx)(o.A,{children:"k"})," was the axis of rotation, represented by the gold arrow ",(0,a.jsx)(o.A,{children:"ki^*=j^*"}),". But what does this mean as an operation on ",(0,a.jsx)(o.A,{children:"k"}),"? One that takes ",(0,a.jsx)(o.A,{children:"k"})," to ",(0,a.jsx)(o.A,{children:"j^*"}),"? Notice that, within the plane of rotation, this is the same as the original rotation that resulted from multiplying ",(0,a.jsx)("i",{children:"on the left"})," by ",(0,a.jsx)(o.A,{children:"i"}),"."]}),(0,a.jsxs)("p",{children:["By both ",(0,a.jsx)("i",{children:"taking the conjugate"})," and multiplying ",(0,a.jsx)("i",{children:"on the right"})," we are both rotating in the opposite direction and from the opposite side, such that the two reverses cancel each other out. Meanwhile, the axis of rotation only cares about which direction the rotation goes, i.e. whether or not we are using the conjugate. By leveraging this difference the rotation doubles up and the twist cancels out, leaving movement only in the plane of rotation!"]}),(0,a.jsxs)(r.h,{children:[(0,a.jsx)(h.default,{src:"quats/ij_vs_ji.png",id:"c1",className:"m-auto cycle max-w-7/8 max-h-100",alt:"ij vs ji."}),(0,a.jsx)(h.default,{src:"quats/i_inverse.png",id:"c2",className:"cycle max-w-7/8 max-h-100",alt:"i*j vs ji*."}),(0,a.jsx)(h.default,{src:"quats/rotation_result.png",id:"c3",className:"cycle max-w-7/8 max-h-100",alt:"The rotation result."})]}),(0,a.jsxs)(i.A,{children:["i(i+j)i^*","(-1+k)i^*","i - j"]}),(0,a.jsxs)("p",{children:["By multiplying on the left by ",(0,a.jsx)(o.A,{children:"i"})," and the right by ",(0,a.jsx)(o.A,{children:"i^*"}),", we have performed a counter-clockwise rotation around ",(0,a.jsx)(o.A,{children:"i"}),". This time we have gone a half turn, as opposed to only a quarter turn in 2d, by performing 2 actions, each involved a quarter turn, in order to do and undo the twist along the axis of rotation."]}),(0,a.jsx)(l.A,{className:"mt-16"}),(0,a.jsxs)("p",{children:["The fact that we have to do and undo the twist means that the amount of rotation done in each step gets doubled up on the whole. This double action is the reason why quaternions use half the angle of the rotation they are meant to represent. Therefore, in order to perform a rotation of angle ",(0,a.jsx)(o.A,{children:"\\theta"})," around axis ",(0,a.jsx)(o.A,{children:"i"}),", we can use a quaternion that looks strikingly similar to a 2d complex number doing the same rotation, but the angle is divided in 2:"]}),(0,a.jsxs)(i.A,{children:["q = \\cos{\\frac{\\theta}{2}}+i\\sin{\\frac{\\theta}{2}}","q^{-1} = \\cos{\\frac{\\theta}{2}}-i\\sin{\\frac{\\theta}{2}}","p' = qpq^{-1}"]}),(0,a.jsxs)("p",{children:["So we've rotated a vector ",(0,a.jsx)(o.A,{children:"p"})," around ",(0,a.jsx)(o.A,{children:"i"})," for an angle ",(0,a.jsx)(o.A,{children:"\\theta"}),". But, seeing as we've defined everything symmetrically, ",(0,a.jsx)(o.A,{children:"i"})," could have been any unit vector involving ",(0,a.jsx)(o.A,{children:"(i,j,k)"})," around which to rotate! Any quaternion with a norm of ",(0,a.jsx)(o.A,{children:"1"}),', called a versor (meaning "turner"), could be substituted in for ',(0,a.jsx)(o.A,{children:"q"})," in order to rotate around its axis."]}),(0,a.jsxs)(s.i,{children:["Getting Yoked","Its a Push and Pull"]}),(0,a.jsxs)("p",{children:["This process of placing a versor and its conjugate on either side is called conjugation. The word ",(0,a.jsx)("i",{children:"conjugate"})," shares a root with the word ",(0,a.jsx)("i",{children:"yoke"}),", as in a beam that binds working oxen. We can say that we have conjugated ",(0,a.jsx)(o.A,{children:"p"})," by ",(0,a.jsx)(o.A,{children:"q"})," in order to rotate it, so ",(0,a.jsx)(o.A,{children:"p"})," and ",(0,a.jsx)(o.A,{children:"p'"})," are related through ",(0,a.jsx)(o.A,{children:"q"})," by conjugation. I suppose that versors are like oxen, working hard to rotate ",(0,a.jsx)(o.A,{children:"p"})," around the axis via the yoke of conjugation!"]}),(0,a.jsx)("p",{children:"Tracing through the operation, we can see how the real component, the twist, gets cancelled out, while the rotation doubles up:"}),(0,a.jsxs)(r.h,{children:[(0,a.jsx)(h.default,{src:"quats/yoke_terms.png",id:"y1",className:"m-auto yoke max-w-9/10 max-h-150",alt:"Yoked terms."}),(0,a.jsx)(h.default,{src:"quats/yoke_actions.png",id:"y2",className:"yoke max-w-9/10 max-h-150",alt:"Yoked actions."})]}),(0,a.jsxs)(i.A,{children:["p = ai + bj + ck","q = \\cos{\\frac{\\theta}{2}} + \\sin{\\frac{\\theta}{2}}\\hat{u}","q^{-1} = \\cos{\\frac{\\theta}{2}} - \\sin{\\frac{\\theta}{2}}\\hat{u}","p' = qpq^{-1}"]})]})}}},e=>{e.O(0,[673,787,901,738,30,358],()=>e(e.s=8914)),_N_E=e.O()}]);